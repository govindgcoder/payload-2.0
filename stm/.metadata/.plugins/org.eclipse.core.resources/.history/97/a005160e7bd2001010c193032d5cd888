/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/* --- MPU6050 Defines --- */
// The MPU6050 default I2C address is 0x68.
// STM32 HAL expects the address shifted left by 1 (0x68 << 1 = 0xD0)
#define MPU6050_ADDR         0xD0
#define MPU_REG_PWR_MGMT_1   0x6B
#define MPU_REG_ACCEL_XOUT_H 0x3B
#define MPU_REG_WHO_AM_I     0x75

/* --- GPS Defines --- */
#define NMEA_BUFFER_SIZE 128

/* Private variables ---------------------------------------------------------*/
I2C_HandleTypeDef hi2c1;   // Handle for I2C (IMU)
UART_HandleTypeDef huart1; // Handle for UART1 (GPS)
UART_HandleTypeDef huart2; // Handle for UART2 (Debug/ESP32)

// --- MPU6050 Data Structure ---
typedef struct {
    int16_t AccX;
    int16_t AccY;
    int16_t AccZ;
    int16_t GyroX;
    int16_t GyroY;
    int16_t GyroZ;
    float Temperature;
} MPU6050_Data_t;

MPU6050_Data_t myMPU;

// --- GPS Variables ---
uint8_t gps_rx_char;
char nmea_buffer[NMEA_BUFFER_SIZE];
uint8_t nmea_idx = 0;
volatile uint8_t gps_data_ready = 0;

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_I2C1_Init(void);
static void MX_USART1_UART_Init(void);
static void MX_USART2_UART_Init(void);

// Helper functions
uint8_t MPU6050_Init(void);
void MPU6050_Read(void);
void Parse_GNGGA(char* nmea);

int main(void)
{
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_I2C1_Init();   // Ensure this is initialized!
  MX_USART2_UART_Init(); // Debug UART

  printf("\n--- STM32 I2C Scanner ---\n");

  while (1)
  {
      printf("Scanning I2C Bus...\n");
      int devices_found = 0;

      for (uint16_t i = 0; i < 128; i++) {
          // HAL_I2C_IsDeviceReady tries to ping the address 'i'
          // We shift 'i' left by 1 because HAL expects the address in the upper 7 bits
          if (HAL_I2C_IsDeviceReady(&hi2c1, (i << 1), 1, 10) == HAL_OK) {
              printf("  Device found at: 0x%02X (HAL Write Addr: 0x%02X)\n", i, (i << 1));
              devices_found++;
          }
      }

      if (devices_found == 0) {
          printf("  No I2C devices found. Check wiring (SDA/SCL)!\n");
      }
      printf("-------------------------\n");
      HAL_Delay(2000);
  }
}

// -------------------------------------------------------------------------
//  MPU6050 Functions (Driverless Implementation)
// -------------------------------------------------------------------------

/**
 * @brief  Initializes the MPU6050 sensor.
 * @retval 0 if successful, 1 if failed.
 */
uint8_t MPU6050_Init(void) {
    uint8_t check;
    uint8_t data;

    // 1. Check WHO_AM_I Register (0x75)
    // We expect the MPU6050 to return 0x68 as its default ID.
    HAL_I2C_Mem_Read(&hi2c1, MPU6050_ADDR, MPU_REG_WHO_AM_I, 1, &check, 1, 1000);

    if (check == 0x68) {
        // 2. Wake up the sensor
        // By default, MPU6050 starts in "Sleep Mode". We must write 0 to PWR_MGMT_1 (0x6B) to wake it.
        data = 0;
        HAL_I2C_Mem_Write(&hi2c1, MPU6050_ADDR, MPU_REG_PWR_MGMT_1, 1, &data, 1, 1000);
        return 0; // Success
    } else {
        return 1; // Error (Device ID mismatch or no connection)
    }
}

/**
 * @brief  Reads raw 6-axis data from the MPU6050.
 * Uses "Burst Read" to get all data in one I2C transaction.
 */
void MPU6050_Read(void) {
    uint8_t Rec_Data[14];

    // Read 14 Bytes starting from ACCEL_XOUT_H (0x3B)
    // The registers are sequential:
    // [AccX_H, AccX_L, AccY_H, AccY_L, AccZ_H, AccZ_L, Temp_H, Temp_L, GyroX_H...]
    HAL_I2C_Mem_Read(&hi2c1, MPU6050_ADDR, MPU_REG_ACCEL_XOUT_H, 1, Rec_Data, 14, 1000);

    // Combine High and Low bytes (MSB and LSB) into signed 16-bit integers
    // We shift the High byte left by 8 bits, then OR it with the Low byte.
    myMPU.AccX = (int16_t)(Rec_Data[0] << 8 | Rec_Data[1]);
    myMPU.AccY = (int16_t)(Rec_Data[2] << 8 | Rec_Data[3]);
    myMPU.AccZ = (int16_t)(Rec_Data[4] << 8 | Rec_Data[5]);

    // Bytes 6 and 7 are Temperature (Skipping conversion for simplicity, but storing it)
    int16_t tempRaw = (int16_t)(Rec_Data[6] << 8 | Rec_Data[7]);
    myMPU.Temperature = (float)((int16_t)tempRaw / 340.0 + 36.53);

    myMPU.GyroX = (int16_t)(Rec_Data[8] << 8 | Rec_Data[9]);
    myMPU.GyroY = (int16_t)(Rec_Data[10] << 8 | Rec_Data[11]);
    myMPU.GyroZ = (int16_t)(Rec_Data[12] << 8 | Rec_Data[13]);
}

// -------------------------------------------------------------------------
//  GPS Parsing Function
// -------------------------------------------------------------------------

void Parse_GNGGA(char* nmea) {
    // Robust parser: Handles empty fields (e.g., ",,") without crashing
    char* current_pos = nmea;
    int field_index = 0;

    float latitude = 0.0, longitude = 0.0;
    int satellites = 0, fix_quality = 0;

    while (*current_pos != '\0') {
        char* next_comma = strchr(current_pos, ',');
        if (next_comma != NULL) {
            *next_comma = '\0'; // Replace comma with NULL terminator temporarily
        }

        if (*current_pos != '\0') { // If field is not empty
            switch (field_index) {
                case 2: latitude = atof(current_pos); break;
                case 4: longitude = atof(current_pos); break;
                case 6: fix_quality = atoi(current_pos); break;
                case 7: satellites = atoi(current_pos); break;
            }
        }

        if (next_comma == NULL) break;
        current_pos = next_comma + 1; // Jump to next field
        field_index++;
    }

    if (fix_quality > 0) {
        printf("GPS> Fix: YES | Sats: %d | Lat: %.4f | Lon: %.4f\n", satellites, latitude, longitude);
    } else {
        printf("GPS> Fix: NO  | Sats: %d\n", satellites);
    }
}

// -------------------------------------------------------------------------
//  Interrupt Service Routine (GPS Receiver)
// -------------------------------------------------------------------------

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
  if (huart->Instance == USART1) {
    // Logic: Buffer character -> Check for newline -> Set Ready Flag
    if (gps_rx_char == '\n' || nmea_idx >= NMEA_BUFFER_SIZE - 1) {
        nmea_buffer[nmea_idx] = '\0';
        gps_data_ready = 1; // Tell Main Loop: "New Data Available!"
        nmea_idx = 0;
    } else if (gps_rx_char != '\r') {
        nmea_buffer[nmea_idx++] = gps_rx_char;
    }
    // Crucial: Re-enable the interrupt for the NEXT character
    HAL_UART_Receive_IT(&huart1, &gps_rx_char, 1);
  }
}

// -------------------------------------------------------------------------
//  Standard HAL Plumbing (Generated Code)
// -------------------------------------------------------------------------
// Redirect printf to UART2 (For debugging)
int _write(int file, char *ptr, int len) { HAL_UART_Transmit(&huart2, (uint8_t*)ptr, len, HAL_MAX_DELAY); return len; }

void SystemClock_Config(void) {
  // Configured for 84MHz (Standard STM32F401/F411 Blackpill/Nucleo config)
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 84;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
}

static void MX_I2C1_Init(void) {
  hi2c1.Instance = I2C1;
  hi2c1.Init.ClockSpeed = 100000; // 100kHz Standard Mode
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  HAL_I2C_Init(&hi2c1);
}

static void MX_USART1_UART_Init(void) {
  huart1.Instance = USART1;
  huart1.Init.BaudRate = 9600; // Standard GPS Baud Rate
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
  HAL_UART_Init(&huart1);
}

static void MX_USART2_UART_Init(void) {
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200; // Fast Debug Baud Rate
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  HAL_UART_Init(&huart2);
}

static void MX_GPIO_Init(void) {
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);
  GPIO_InitStruct.Pin = GPIO_PIN_13;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
}

void Error_Handler(void) {
  __disable_irq();
  while (1) {}
}
