/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>

/* --- Hardware Defines --- */
#define MPU6050_ADDR         0xD0
#define MPU_REG_WHO_AM_I     0x75
#define MPU_REG_PWR_MGMT_1   0x6B
#define MPU_REG_GYRO_CONFIG  0x1B
#define MPU_REG_ACCEL_CONFIG 0x1C
#define MPU_REG_ACCEL_XOUT_H 0x3B
#define MPU_1G_RAW           2048
#define NMEA_BUFFER_SIZE     128
#define PI 					 3.14159265

/* Private variables ---------------------------------------------------------*/
I2C_HandleTypeDef hi2c1;
UART_HandleTypeDef huart1; // GPS
UART_HandleTypeDef huart2; // ESP32 (TX=Telemetry Out, RX=Baro In)

// --- UNIFIED SYSTEM STATE ---
typedef struct {
	// IMU Data
	int16_t AccX, AccY, AccZ;
	int16_t GyroX, GyroY, GyroZ;

	// GPS Data
	float Latitude;
	float Longitude;
	int Satellites;
	uint8_t FixStatus; // 0=No Fix, 1=Fix

	// Barometer Data (from ESP32)
	float BaroAlt;
} RocketState_t;

RocketState_t vehicleState = { 0 };

//Madgwick filter

typedef struct quaternion {
	float q0;
	float q1;
	float q2;
	float q3;
	float beta;
	float sampleFreq;
} quaternion;

void madgwickUpdate(quaternion *q, float ax, float ay, float az, float gx,
		float gy, float gz);

// --- Barometer Rx Variables ---
uint8_t baro_rx_byte;
uint8_t baro_buffer[4];
uint8_t baro_idx = 0;
uint8_t baro_state = 0; // 0=Header, 1=Data, 2=Footer

// --- Calibration Globals ---
int16_t AccX_Offset = 0, AccY_Offset = 0, AccZ_Offset = 0;
int16_t GyroX_Offset = 0, GyroY_Offset = 0, GyroZ_Offset = 0;
uint8_t Vertical_Axis = 2;
int8_t Vertical_Sign = 1;

// --- GPS Variables ---
uint8_t gps_rx_char;
char nmea_buffer[NMEA_BUFFER_SIZE];
uint8_t nmea_idx = 0;
volatile uint8_t gps_data_ready = 0;

/* Prototypes */
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_I2C1_Init(void);
static void MX_USART1_UART_Init(void);
static void MX_USART2_UART_Init(void);
uint8_t MPU6050_Init(void);
void MPU6050_Calibrate(void);
void MPU6050_Read_AccelGyro(void);
void Parse_GGA_Generic(char *nmea);

int main(void) {
	HAL_Init();
	SystemClock_Config();
	MX_GPIO_Init();
	MX_I2C1_Init();
	MX_USART1_UART_Init();
	MX_USART2_UART_Init(); // This function now includes the Interrupt Enable fix

	printf("\n--- VeloCET Payload: Data Fusion Active ---\n");

	if (MPU6050_Init() == 0)
		printf("MPU6050 OK.\n");
	else
		printf("MPU6050 FAIL.\n");

	printf("Calibrating IMU... Keep Still.\n");
	HAL_Delay(2000);
	MPU6050_Calibrate();
	printf("Ready. Listening for GPS & Barometer...\n");

	// Start Interrupts
	HAL_UART_Receive_IT(&huart1, &gps_rx_char, 1);
	HAL_UART_Receive_IT(&huart2, &baro_rx_byte, 1);

	uint32_t start_time = HAL_GetTick();

	float f_ax, f_ay, f_az, f_gx, f_gy, f_gz;

	quaternion rocketQ = { 0 };
	rocketQ.beta = 0.1;
	rocketQ.q0 = 1.0;
	rocketQ.sampleFreq = 100.0;

	//for drift debug
	quaternion driftQ = { 0 };
	driftQ.beta = 0.0f;          // Correction OFF (Beta = 0)
	driftQ.q0 = 1.0f;
	driftQ.sampleFreq = 100.0f;

	while (1) {
		HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);

		//100hz
		if (HAL_GetTick() - start_time > 10) {
			//gps data ready
			if (gps_data_ready) {
				if (strstr(nmea_buffer, "GGA") != NULL)
					Parse_GGA_Generic(nmea_buffer);
				//update current position with GPS correction for EKF
				gps_data_ready = 0;
			}
			MPU6050_Read_AccelGyro();
			//convert raw data to float
			f_ax = vehicleState.AccX;
			f_ay = vehicleState.AccY;
			f_az = vehicleState.AccZ;
			f_gx = vehicleState.GyroX;
			f_gy = vehicleState.GyroY;
			f_gz = vehicleState.GyroZ;

			//acc:
			f_ax /= 2048;
			f_ay /= 2048;
			f_az /= 2048;

			//gyro:
			f_gx = (f_gx / 16.4) * (PI / 180);
			f_gy = (f_gy / 16.4) * (PI / 180);
			f_gz = (f_gz / 16.4) * (PI / 180);

			madgwickUpdate(&rocketQ, f_ax, f_ay, f_az, f_gx, f_gy, f_gz);
			madgwickUpdate(&driftQ, f_ax, f_ay, f_az, f_gx, f_gy, f_gz);
			printf("S,%.4f,%.4f,%.4f,%.4f,%.4f,%.4f,%.4f,%.4f,E\r\n",
				       rocketQ.q0, rocketQ.q1, rocketQ.q2, rocketQ.q3,
				       driftQ.q0,  driftQ.q1,  driftQ.q2,  driftQ.q3);

			start_time = HAL_GetTick();
		}
	}
}

//function definitions

void madgwickUpdate(quaternion *q, float ax, float ay, float az, float gx,
		float gy, float gz) {
	float q0 = q->q0, q1 = q->q1, q2 = q->q2, q3 = q->q3;
	float norm;
	float s0, s1, s2, s3;
	float qDot1, qDot2, qDot3, qDot4;

	qDot1 = 0.5f * (-q1 * gx - q2 * gy - q3 * gz);
	qDot2 = 0.5f * (q0 * gx + q2 * gz - q3 * gy);
	qDot3 = 0.5f * (q0 * gy - q1 * gz + q3 * gx);
	qDot4 = 0.5f * (q0 * gz + q1 * gy - q2 * gx);

	if (!((ax == 0.0f) && (ay == 0.0f) && (az == 0.0f))) {

		norm = sqrtf(ax * ax + ay * ay + az * az);
		if (norm == 0.0)
			return;
		ax /= norm;
		ay /= norm;
		az /= norm;

		float _2q0 = 2.0f * q0;
		float _2q1 = 2.0f * q1;
		float _2q2 = 2.0f * q2;
		float _2q3 = 2.0f * q3;
		float _4q0 = 4.0f * q0;
		float _4q1 = 4.0f * q1;
		float _4q2 = 4.0f * q2;
		float _8q1 = 8.0f * q1;
		float _8q2 = 8.0f * q2;
		float q0q0 = q0 * q0;
		float q1q1 = q1 * q1;
		float q2q2 = q2 * q2;
		float q3q3 = q3 * q3;

		//gradient descent

		s0 = _4q0 * q2q2 + _2q2 * ax + _4q0 * q1q1 - _2q1 * ay;
		s1 = _4q1 * q3q3 - _2q3 * ax + 4.0f * q0q0 * q1 - _2q0 * ay - _4q1
				+ _8q1 * q1q1 + _8q1 * q2q2 + _4q1 * az;
		s2 = 4.0f * q0q0 * q2 + _2q0 * ax + _4q2 * q3q3 - _2q3 * ay - _4q2
				+ _8q2 * q1q1 + _8q2 * q2q2 + _4q2 * az;
		s3 = 4.0f * q1q1 * q3 - _2q1 * ax + 4.0f * q2q2 * q3 - _2q2 * ay;

		norm = sqrtf(s0 * s0 + s1 * s1 + s2 * s2 + s3 * s3);
		if (norm > 0.0) {
			s0 /= norm;
			s1 /= norm;
			s2 /= norm;
			s3 /= norm;

			qDot1 -= q->beta * s0;
			qDot2 -= q->beta * s1;
			qDot3 -= q->beta * s2;
			qDot4 -= q->beta * s3;
		}
	}

	// new pos = pos + (Rate * dt)
	float dt = 1.0f / q->sampleFreq;
	q0 += qDot1 * dt;
	q1 += qDot2 * dt;
	q2 += qDot3 * dt;
	q3 += qDot4 * dt;

	// 5. Normalise final quaternion
	// (Output must always be a unit vector)
	norm = sqrtf(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
	if (norm > 0.0) {
		q->q0 = q0 / norm;
		q->q1 = q1 / norm;
		q->q2 = q2 / norm;
		q->q3 = q3 / norm;

	}
}

// -------------------------------------------------------------------------
//  INTERRUPT HANDLERS (CRITICAL)
// -------------------------------------------------------------------------

// 1. The Hardware Hook
void USART2_IRQHandler(void) {
	HAL_UART_IRQHandler(&huart2);
}

// 2. The Logic Callback
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {

	// GPS (UART 1)
	if (huart->Instance == USART1) {
		if (gps_rx_char == '\n' || nmea_idx >= NMEA_BUFFER_SIZE - 1) {
			nmea_buffer[nmea_idx] = '\0';
			gps_data_ready = 1;
			nmea_idx = 0;
		} else if (gps_rx_char != '\r') {
			nmea_buffer[nmea_idx++] = gps_rx_char;
		}
		HAL_UART_Receive_IT(&huart1, &gps_rx_char, 1);
	}

	// Barometer from ESP32 (UART 2)
	else if (huart->Instance == USART2) {
		switch (baro_state) {
		case 0: // Header
			if (baro_rx_byte == 0xBB) {
				baro_idx = 0;
				baro_state = 1;
			}
			break;
		case 1: // Data
			baro_buffer[baro_idx++] = baro_rx_byte;
			if (baro_idx >= 4)
				baro_state = 2;
			break;
		case 2: // Footer
			if (baro_rx_byte == 0x55) {
				memcpy(&vehicleState.BaroAlt, baro_buffer, 4);
			}
			baro_state = 0;
			break;
		}
		HAL_UART_Receive_IT(&huart2, &baro_rx_byte, 1);
	}
}

// 3. Error Callback (Auto-restart on noise)
void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart) {
	if (huart->Instance == USART2) {
		volatile uint32_t er = HAL_UART_GetError(huart); // Clear flag
		HAL_UART_Receive_IT(&huart2, &baro_rx_byte, 1);  // Restart
	} else if (huart->Instance == USART1) {
		volatile uint32_t er = HAL_UART_GetError(huart);
		HAL_UART_Receive_IT(&huart1, &gps_rx_char, 1);
	}
}

// -------------------------------------------------------------------------
//  Standard Helper Functions (Init, Read, Parse)
// -------------------------------------------------------------------------
int _write(int file, char *ptr, int len) {
	HAL_UART_Transmit(&huart2, (uint8_t*) ptr, len, HAL_MAX_DELAY);
	return len;
}

// --- Initialization Functions (With fixes) ---
static void MX_USART2_UART_Init(void) {
	huart2.Instance = USART2;
	huart2.Init.BaudRate = 115200;
	huart2.Init.WordLength = UART_WORDLENGTH_8B;
	huart2.Init.StopBits = UART_STOPBITS_1;
	huart2.Init.Parity = UART_PARITY_NONE;
	huart2.Init.Mode = UART_MODE_TX_RX;
	huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
	huart2.Init.OverSampling = UART_OVERSAMPLING_16;

	// Init and Error Check
	if (HAL_UART_Init(&huart2) != HAL_OK) {
		Error_Handler();
	}

	// Manually Enable Interrupts
	HAL_NVIC_SetPriority(USART2_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(USART2_IRQn);
}

// --- Standard Functions (MPU, GPS, System) ---
void Parse_GGA_Generic(char *nmea) {
	char *current_pos = nmea;
	int field_index = 0;
	float t_lat = 0.0, t_lon = 0.0;
	int t_sats = 0, t_fix = 0;
	while (*current_pos != '\0') {
		char *next_comma = strchr(current_pos, ',');
		if (next_comma != NULL)
			*next_comma = '\0';
		if (*current_pos != '\0') {
			switch (field_index) {
			case 2:
				t_lat = atof(current_pos);
				break;
			case 4:
				t_lon = atof(current_pos);
				break;
			case 6:
				t_fix = atoi(current_pos);
				break;
			case 7:
				t_sats = atoi(current_pos);
				break;
			}
		}
		if (next_comma == NULL)
			break;
		current_pos = next_comma + 1;
		field_index++;
	}
	vehicleState.Latitude = t_lat;
	vehicleState.Longitude = t_lon;
	vehicleState.FixStatus = t_fix;
	vehicleState.Satellites = t_sats;
}

uint8_t MPU6050_Init(void) {
	uint8_t check, data;
	HAL_I2C_Mem_Read(&hi2c1, MPU6050_ADDR, MPU_REG_WHO_AM_I, 1, &check, 1,
			1000);
	if (check == 0x68) {
		data = 0x00;
		HAL_I2C_Mem_Write(&hi2c1, MPU6050_ADDR, MPU_REG_PWR_MGMT_1, 1, &data, 1,
				1000);
		data = 0x18;
		HAL_I2C_Mem_Write(&hi2c1, MPU6050_ADDR, MPU_REG_GYRO_CONFIG, 1, &data,
				1, 1000);
		data = 0x18;
		HAL_I2C_Mem_Write(&hi2c1, MPU6050_ADDR, MPU_REG_ACCEL_CONFIG, 1, &data,
				1, 1000);
		return 0;
	}
	return 1;
}

void MPU6050_Calibrate(void) {
	int32_t Aa[3] = { 0 }, Ag[3] = { 0 };
	uint8_t Rec[14];
	for (int i = 0; i < 1000; i++) {
		HAL_I2C_Mem_Read(&hi2c1, MPU6050_ADDR, MPU_REG_ACCEL_XOUT_H, 1, Rec, 14,
				1000);
		Aa[0] += (int16_t) (Rec[0] << 8 | Rec[1]);
		Aa[1] += (int16_t) (Rec[2] << 8 | Rec[3]);
		Aa[2] += (int16_t) (Rec[4] << 8 | Rec[5]);
		Ag[0] += (int16_t) (Rec[8] << 8 | Rec[9]);
		Ag[1] += (int16_t) (Rec[10] << 8 | Rec[11]);
		Ag[2] += (int16_t) (Rec[12] << 8 | Rec[13]);
		HAL_Delay(1);
	}
	int16_t AvgX = Aa[0] / 1000, AvgY = Aa[1] / 1000, AvgZ = Aa[2] / 1000;
	if (abs(AvgX) > abs(AvgY) && abs(AvgX) > abs(AvgZ)) {
		Vertical_Axis = 0;
		Vertical_Sign = (AvgX > 0) ? 1 : -1;
	} else if (abs(AvgY) > abs(AvgX) && abs(AvgY) > abs(AvgZ)) {
		Vertical_Axis = 1;
		Vertical_Sign = (AvgY > 0) ? 1 : -1;
	} else {
		Vertical_Axis = 2;
		Vertical_Sign = (AvgZ > 0) ? 1 : -1;
	}
	GyroX_Offset = Ag[0] / 1000;
	GyroY_Offset = Ag[1] / 1000;
	GyroZ_Offset = Ag[2] / 1000;
	int16_t gRaw = MPU_1G_RAW * Vertical_Sign;
	AccX_Offset = AvgX;
	AccY_Offset = AvgY;
	AccZ_Offset = AvgZ;
	if (Vertical_Axis == 0)
		AccX_Offset -= gRaw;
	if (Vertical_Axis == 1)
		AccY_Offset -= gRaw;
	if (Vertical_Axis == 2)
		AccZ_Offset -= gRaw;
}

void MPU6050_Read_AccelGyro(void) {
	uint8_t Rec[14];
	HAL_I2C_Mem_Read(&hi2c1, MPU6050_ADDR, MPU_REG_ACCEL_XOUT_H, 1, Rec, 14,
			1000);
	int16_t rX = (int16_t) (Rec[0] << 8 | Rec[1]), rY = (int16_t) (Rec[2] << 8
			| Rec[3]), rZ = (int16_t) (Rec[4] << 8 | Rec[5]);
	int16_t rGx = (int16_t) (Rec[8] << 8 | Rec[9]), rGy = (int16_t) (Rec[10]
			<< 8 | Rec[11]), rGz = (int16_t) (Rec[12] << 8 | Rec[13]);
	rX -= AccX_Offset;
	rY -= AccY_Offset;
	rZ -= AccZ_Offset;
	rGx -= GyroX_Offset;
	rGy -= GyroY_Offset;
	rGz -= GyroZ_Offset;
	if (Vertical_Axis == 0) {
		vehicleState.AccZ = rX * Vertical_Sign;
		vehicleState.AccY = rY;
		vehicleState.AccX = rZ;
		vehicleState.GyroZ = rGx * Vertical_Sign;
		vehicleState.GyroY = rGy;
		vehicleState.GyroX = rGz;
	} else if (Vertical_Axis == 1) {
		vehicleState.AccZ = rY * Vertical_Sign;
		vehicleState.AccX = rX;
		vehicleState.AccY = rZ;
		vehicleState.GyroZ = rGy * Vertical_Sign;
		vehicleState.GyroX = rGx;
		vehicleState.GyroY = rGz;
	} else {
		vehicleState.AccZ = rZ * Vertical_Sign;
		vehicleState.AccX = rX;
		vehicleState.AccY = rY;
		vehicleState.GyroZ = rGz * Vertical_Sign;
		vehicleState.GyroX = rGx;
		vehicleState.GyroY = rGy;
	}
}

void SystemClock_Config(void) {
	RCC_OscInitTypeDef RCC_OscInitStruct = { 0 };
	RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 };
	__HAL_RCC_PWR_CLK_ENABLE();
	__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
	RCC_OscInitStruct.HSIState = RCC_HSI_ON;
	RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
	RCC_OscInitStruct.PLL.PLLM = 8;
	RCC_OscInitStruct.PLL.PLLN = 84;
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
	RCC_OscInitStruct.PLL.PLLQ = 4;
	HAL_RCC_OscConfig(&RCC_OscInitStruct);
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK
			| RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
	HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
}
static void MX_I2C1_Init(void) {
	hi2c1.Instance = I2C1;
	hi2c1.Init.ClockSpeed = 100000;
	hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
	hi2c1.Init.OwnAddress1 = 0;
	hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
	hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
	hi2c1.Init.OwnAddress2 = 0;
	hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
	hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
	HAL_I2C_Init(&hi2c1);
}
static void MX_USART1_UART_Init(void) {
	huart1.Instance = USART1;
	huart1.Init.BaudRate = 9600;
	huart1.Init.WordLength = UART_WORDLENGTH_8B;
	huart1.Init.StopBits = UART_STOPBITS_1;
	huart1.Init.Parity = UART_PARITY_NONE;
	huart1.Init.Mode = UART_MODE_TX_RX;
	huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
	huart1.Init.OverSampling = UART_OVERSAMPLING_16;
	HAL_UART_Init(&huart1);
}
static void MX_GPIO_Init(void) {
	GPIO_InitTypeDef GPIO_InitStruct = { 0 };
	__HAL_RCC_GPIOC_CLK_ENABLE();
	__HAL_RCC_GPIOA_CLK_ENABLE();
	__HAL_RCC_GPIOB_CLK_ENABLE();
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);
	GPIO_InitStruct.Pin = GPIO_PIN_13;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
}
void Error_Handler(void) {
	__disable_irq();
	while (1) {
	}
}
