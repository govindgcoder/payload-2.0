/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>

/* --- MPU6050 Defines --- */
#define MPU6050_ADDR         0xD0
#define MPU_REG_WHO_AM_I     0x75
#define MPU_REG_PWR_MGMT_1   0x6B
#define MPU_REG_GYRO_CONFIG  0x1B
#define MPU_REG_ACCEL_CONFIG 0x1C
#define MPU_REG_ACCEL_XOUT_H 0x3B

// Sensitivity Scaling (For 16g range, 1g = 2048 raw)
#define MPU_1G_RAW           2048

/* --- GPS Defines --- */
#define NMEA_BUFFER_SIZE     128

/* Private variables ---------------------------------------------------------*/
I2C_HandleTypeDef hi2c1;
UART_HandleTypeDef huart1;
UART_HandleTypeDef huart2;

// --- MPU6050 Data Structure ---
typedef struct {
    int16_t AccX;
    int16_t AccY;
    int16_t AccZ;   // Always mapped to Vertical Axis
    int16_t GyroX;
    int16_t GyroY;
    int16_t GyroZ;
} MPU6050_Data_t;

MPU6050_Data_t myMPU;

// --- Calibration Globals ---
int16_t AccX_Offset=0, AccY_Offset=0, AccZ_Offset=0;
int16_t GyroX_Offset=0, GyroY_Offset=0, GyroZ_Offset=0;

// Orientation flags
uint8_t Vertical_Axis = 2; // 0=X, 1=Y, 2=Z
int8_t  Vertical_Sign = 1; // 1 for Upright, -1 for Upside down

// --- GPS Variables ---
uint8_t gps_rx_char;
char nmea_buffer[NMEA_BUFFER_SIZE];
uint8_t nmea_idx = 0;
volatile uint8_t gps_data_ready = 0;

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_I2C1_Init(void);
static void MX_USART1_UART_Init(void);
static void MX_USART2_UART_Init(void);

// Sensor Functions
uint8_t MPU6050_Init(void);
void MPU6050_Calibrate(void);
void MPU6050_Read_AccelGyro(void);
void Parse_GNGGA(char* nmea);

int main(void)
{
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_I2C1_Init();
  MX_USART1_UART_Init();
  MX_USART2_UART_Init();

  printf("\n--- VeloCET Payload: Auto-Orientation Mode ---\n");

  // 1. Initialize MPU
  if (MPU6050_Init() == 0) {
      printf("SUCCESS: MPU6050 Initialized.\n");
  } else {
      printf("FAILURE: MPU6050 not found!\n");
      // Stop execution if sensor fails
      while(1) {
          HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
          HAL_Delay(100);
      }
  }

  // 2. Auto-Calibrate (Must be static on rail)
  printf("Calibrating Orientation... KEEP STILL!\n");
  HAL_Delay(2000);
  MPU6050_Calibrate();
  printf("Calibration Complete. Vertical Axis detected: %d\n", Vertical_Axis);

  // 3. Start GPS Interrupts
  HAL_UART_Receive_IT(&huart1, &gps_rx_char, 1);
  printf("Main Loop Running.\n");

  while (1)
  {
    HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);

    // Handle GPS
    if (gps_data_ready) {
        if (strncmp(nmea_buffer, "$GNGGA", 6) == 0) {
            Parse_GNGGA(nmea_buffer);
        }
        gps_data_ready = 0;
    }

    // Handle IMU
    MPU6050_Read_AccelGyro();

    printf("IMU (Z=Up)> Acc: %d,%d,%d | Gyr: %d,%d,%d\n",
           myMPU.AccX, myMPU.AccY, myMPU.AccZ,
           myMPU.GyroX, myMPU.GyroY, myMPU.GyroZ);

    HAL_Delay(100);
  }
}

// -------------------------------------------------------------------------
//  MPU6050 Driver
// -------------------------------------------------------------------------

uint8_t MPU6050_Init(void) {
    uint8_t check;
    uint8_t data;

    // Check ID (WhoAmI)
    HAL_I2C_Mem_Read(&hi2c1, MPU6050_ADDR, MPU_REG_WHO_AM_I, 1, &check, 1, 1000);

    if (check == 0x68) {
        // Wake Up
        data = 0x00;
        HAL_I2C_Mem_Write(&hi2c1, MPU6050_ADDR, MPU_REG_PWR_MGMT_1, 1, &data, 1, 1000);

        // Gyro: +/- 2000 dps
        data = 0x18;
        HAL_I2C_Mem_Write(&hi2c1, MPU6050_ADDR, MPU_REG_GYRO_CONFIG, 1, &data, 1, 1000);

        // Accel: +/- 16g
        data = 0x18;
        HAL_I2C_Mem_Write(&hi2c1, MPU6050_ADDR, MPU_REG_ACCEL_CONFIG, 1, &data, 1, 1000);

        return 0; // OK
    }
    return 1; // Error
}

void MPU6050_Calibrate(void) {
    int32_t Aa[3] = {0,0,0};
    int32_t Ag[3] = {0,0,0};
    uint8_t Rec_Data[14];

    // 1. Accumulate Samples
    for(int i=0; i<1000; i++) {
        HAL_I2C_Mem_Read(&hi2c1, MPU6050_ADDR, MPU_REG_ACCEL_XOUT_H, 1, Rec_Data, 14, 1000);

        // Raw Accel
        Aa[0] += (int16_t)(Rec_Data[0] << 8 | Rec_Data[1]);
        Aa[1] += (int16_t)(Rec_Data[2] << 8 | Rec_Data[3]);
        Aa[2] += (int16_t)(Rec_Data[4] << 8 | Rec_Data[5]);

        // Raw Gyro
        Ag[0] += (int16_t)(Rec_Data[8] << 8 | Rec_Data[9]);
        Ag[1] += (int16_t)(Rec_Data[10] << 8 | Rec_Data[11]);
        Ag[2] += (int16_t)(Rec_Data[12] << 8 | Rec_Data[13]);

        // Blocking delay is fine during initialization
        HAL_Delay(1);
    }

    // 2. Calculate Averages
    int16_t AvgAccX = Aa[0] / 1000;
    int16_t AvgAccY = Aa[1] / 1000;
    int16_t AvgAccZ = Aa[2] / 1000;

    // 3. Detect Orientation
    int16_t absX = abs(AvgAccX);
    int16_t absY = abs(AvgAccY);
    int16_t absZ = abs(AvgAccZ);

    if (absX > absY && absX > absZ) {
        Vertical_Axis = 0;
        Vertical_Sign = (AvgAccX > 0) ? 1 : -1;
    } else if (absY > absX && absY > absZ) {
        Vertical_Axis = 1;
        Vertical_Sign = (AvgAccY > 0) ? 1 : -1;
    } else {
        Vertical_Axis = 2;
        Vertical_Sign = (AvgAccZ > 0) ? 1 : -1;
    }

    // 4. Set Offsets
    GyroX_Offset = Ag[0] / 1000;
    GyroY_Offset = Ag[1] / 1000;
    GyroZ_Offset = Ag[2] / 1000;

    // Expected Gravity Reading based on Sign
    int16_t gravity_raw = MPU_1G_RAW * Vertical_Sign;

    // Subtract gravity ONLY from the vertical axis
    AccX_Offset = AvgAccX;
    AccY_Offset = AvgAccY;
    AccZ_Offset = AvgAccZ;

    if (Vertical_Axis == 0) AccX_Offset -= gravity_raw;
    if (Vertical_Axis == 1) AccY_Offset -= gravity_raw;
    if (Vertical_Axis == 2) AccZ_Offset -= gravity_raw;
}

void MPU6050_Read_AccelGyro(void) {
    uint8_t Rec_Data[14];
    HAL_I2C_Mem_Read(&hi2c1, MPU6050_ADDR, MPU_REG_ACCEL_XOUT_H, 1, Rec_Data, 14, 1000);

    // 1. Read Raw
    int16_t rawX = (int16_t)(Rec_Data[0] << 8 | Rec_Data[1]);
    int16_t rawY = (int16_t)(Rec_Data[2] << 8 | Rec_Data[3]);
    int16_t rawZ = (int16_t)(Rec_Data[4] << 8 | Rec_Data[5]);

    int16_t rawGx = (int16_t)(Rec_Data[8] << 8 | Rec_Data[9]);
    int16_t rawGy = (int16_t)(Rec_Data[10] << 8 | Rec_Data[11]);
    int16_t rawGz = (int16_t)(Rec_Data[12] << 8 | Rec_Data[13]);

    // 2. Apply Calibration
    rawX -= AccX_Offset;
    rawY -= AccY_Offset;
    rawZ -= AccZ_Offset;
    rawGx -= GyroX_Offset;
    rawGy -= GyroY_Offset;
    rawGz -= GyroZ_Offset;

    // 3. Remap Axes (Smart Orientation)
    // We swap the detected physical vertical axis into the virtual Z variable.
    // NOTE: This also corrects the sign so Z is always positive UP.

    if (Vertical_Axis == 0) { // X is Vertical
        myMPU.AccZ = rawX * Vertical_Sign;
        myMPU.AccY = rawY;
        myMPU.AccX = rawZ;
    }
    else if (Vertical_Axis == 1) { // Y is Vertical
        myMPU.AccZ = rawY * Vertical_Sign;
        myMPU.AccX = rawX;
        myMPU.AccY = rawZ;
    }
    else { // Z is Vertical
        myMPU.AccZ = rawZ * Vertical_Sign;
        myMPU.AccX = rawX;
        myMPU.AccY = rawY;
    }

    // Remap Gyros to match (Basic remapping, sign flip might be needed depending on mount)
    if (Vertical_Axis == 0) { myMPU.GyroZ = rawGx; myMPU.GyroY = rawGy; myMPU.GyroX = rawGz; }
    else if (Vertical_Axis == 1) { myMPU.GyroZ = rawGy; myMPU.GyroX = rawGx; myMPU.GyroY = rawGz; }
    else { myMPU.GyroZ = rawGz; myMPU.GyroX = rawGx; myMPU.GyroY = rawGy; }
}

// -------------------------------------------------------------------------
//  GPS & HAL Boilerplate
// -------------------------------------------------------------------------

void Parse_GNGGA(char* nmea) {
    char* current_pos = nmea;
    int field_index = 0;
    float latitude = 0.0, longitude = 0.0;
    int satellites = 0, fix_quality = 0;

    while (*current_pos != '\0') {
        char* next_comma = strchr(current_pos, ',');
        if (next_comma != NULL) *next_comma = '\0';

        if (*current_pos != '\0') {
            switch (field_index) {
                case 2: latitude = atof(current_pos); break;
                case 4: longitude = atof(current_pos); break;
                case 6: fix_quality = atoi(current_pos); break;
                case 7: satellites = atoi(current_pos); break;
            }
        }
        if (next_comma == NULL) break;
        current_pos = next_comma + 1;
        field_index++;
    }
    if (fix_quality > 0) printf("GPS> Fix: YES | Sats: %d | Lat: %.4f\n", satellites, latitude);
    else printf("GPS> Fix: NO | Sats: %d\n", satellites);
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
  if (huart->Instance == USART1) {
    if (gps_rx_char == '\n' || nmea_idx >= NMEA_BUFFER_SIZE - 1) {
        nmea_buffer[nmea_idx] = '\0';
        gps_data_ready = 1;
        nmea_idx = 0;
    } else if (gps_rx_char != '\r') {
        nmea_buffer[nmea_idx++] = gps_rx_char;
    }
    HAL_UART_Receive_IT(&huart1, &gps_rx_char, 1);
  }
}

int _write(int file, char *ptr, int len) { HAL_UART_Transmit(&huart2, (uint8_t*)ptr, len, HAL_MAX_DELAY); return len; }

/* ... (Keep your SystemClock_Config and MX_Inits exactly as they were) ... */
void SystemClock_Config(void) {
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 84;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
}
static void MX_I2C1_Init(void) {
  hi2c1.Instance = I2C1; hi2c1.Init.ClockSpeed = 100000; hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2; hi2c1.Init.OwnAddress1 = 0; hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT; hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE; hi2c1.Init.OwnAddress2 = 0; hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE; hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE; HAL_I2C_Init(&hi2c1);
}
static void MX_USART1_UART_Init(void) {
  huart1.Instance = USART1; huart1.Init.BaudRate = 9600; huart1.Init.WordLength = UART_WORDLENGTH_8B; huart1.Init.StopBits = UART_STOPBITS_1; huart1.Init.Parity = UART_PARITY_NONE; huart1.Init.Mode = UART_MODE_TX_RX; huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart1.Init.OverSampling = UART_OVERSAMPLING_16; HAL_UART_Init(&huart1);
}
static void MX_USART2_UART_Init(void) {
  huart2.Instance = USART2; huart2.Init.BaudRate = 115200; huart2.Init.WordLength = UART_WORDLENGTH_8B; huart2.Init.StopBits = UART_STOPBITS_1; huart2.Init.Parity = UART_PARITY_NONE; huart2.Init.Mode = UART_MODE_TX_RX; huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart2.Init.OverSampling = UART_OVERSAMPLING_16; HAL_UART_Init(&huart2);
}
static void MX_GPIO_Init(void) {
  GPIO_InitTypeDef GPIO_InitStruct = {0}; __HAL_RCC_GPIOC_CLK_ENABLE(); __HAL_RCC_GPIOA_CLK_ENABLE(); __HAL_RCC_GPIOB_CLK_ENABLE(); HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET); GPIO_InitStruct.Pin = GPIO_PIN_13; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
}
void Error_Handler(void) { __disable_irq(); while (1) {} }
