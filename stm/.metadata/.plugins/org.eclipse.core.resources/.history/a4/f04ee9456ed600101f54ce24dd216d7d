/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>

/* --- Configuration & Constants --- */
#define MPU6050_ADDR         0xD0
#define MPU_REG_WHO_AM_I     0x75
#define MPU_REG_PWR_MGMT_1   0x6B
#define MPU_REG_GYRO_CONFIG  0x1B
#define MPU_REG_ACCEL_CONFIG 0x1C
#define MPU_REG_ACCEL_XOUT_H 0x3B

#define MPU_ACCEL_SENS       2048.0f
#define MPU_GYRO_SENS        16.4f
#define PI                   3.14159265f
#define DEG_TO_RAD           (PI / 180.0f)
#define NMEA_BUFFER_SIZE     128

#define BARO_HEADER          0xBB
#define BARO_FOOTER          0x55

/* --- Data Structures --- */
typedef struct {
	int16_t AccX, AccY, AccZ;
	int16_t GyroX, GyroY, GyroZ;
	float   Latitude, Longitude;
	int     Satellites;
	uint8_t FixStatus;
	float   BaroAlt;
} RocketState_t;

typedef struct {
	float q0, q1, q2, q3;
	float beta;
	float sampleFreq;
} Quaternion_t;

typedef struct {
	float pos;
	float vel;
	float P[2][2];
	float Q[2];
} KState;

/* --- Global Variables --- */
RocketState_t vehicleState = {0};
Quaternion_t rocketQ = {1.0f, 0.0f, 0.0f, 0.0f, 0.1f, 100.0f};

// Peripherals
I2C_HandleTypeDef hi2c1;
UART_HandleTypeDef huart1; // GPS
UART_HandleTypeDef huart2; // Telemetry/Baro

// Buffers & Flags
char nmea_buffer[NMEA_BUFFER_SIZE];
uint8_t gps_rx_char;
uint8_t nmea_idx = 0;
volatile uint8_t gps_data_ready = 0;

uint8_t baro_rx_byte;
uint8_t baro_buffer[4];
uint8_t baro_idx = 0;
uint8_t baro_state = 0; // 0=Header, 1=Data, 2=Footer
int baro_update=0;

// IMU Calibration
int16_t Acc_Offset[3] = {0}, Gyro_Offset[3] = {0};
uint8_t Vertical_Axis = 2; // 0=X, 1=Y, 2=Z
int8_t  Vertical_Sign = 1;

/* --- Function Prototypes --- */
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_I2C1_Init(void);
static void MX_USART1_UART_Init(void);
static void MX_USART2_UART_Init(void);

uint8_t MPU6050_Init(void);
void MPU6050_Calibrate(void);
void MPU6050_Read_AccelGyro(void);
void Parse_GGA_Generic(char *nmea);
void MadgwickUpdate(Quaternion_t *q, float ax, float ay, float az, float gx, float gy, float gz);
void GravityCorrection(Quaternion_t *q, float *lx, float *ly, float *lz, float ax, float ay, float az);
void KPredict(KState *k, float acc, float dt);
void KUpdate(KState *k, float m, float R);

/* --- Main Application --- */
int main(void) {
	HAL_Init();
	SystemClock_Config();
	MX_GPIO_Init();
	MX_I2C1_Init();
	MX_USART1_UART_Init();
	MX_USART2_UART_Init();

	// IMU Setup
	if (MPU6050_Init() != 0) {
		// Error Handler (Optional: Add LED Blink here)
	}

	HAL_Delay(2000); // Wait for sensor to stabilize
	MPU6050_Calibrate();

	//baro update flag

	// Start Interrupts
	HAL_UART_Receive_IT(&huart1, &gps_rx_char, 1);
	HAL_UART_Receive_IT(&huart2, &baro_rx_byte, 1);

	uint32_t last_tick = HAL_GetTick();
	float f_ax, f_ay, f_az, f_gx, f_gy, f_gz;
	float lx, ly, lz;

	float dt=0.01;

	//kalman filter
	KState kZ = {0};
	kZ.pos = 0.0f; // Start at 0m
	kZ.vel = 0.0f; // Start at 0m/s

	// Initial Uncertainty
	kZ.P[0][0] = 1.0f; kZ.P[0][1] = 0.0f;
	kZ.P[1][0] = 0.0f; kZ.P[1][1] = 1.0f;

	// Process Noise (Tuning Knobs)
	// Q[0] = Position Noise (small)
	// Q[1] = Velocity/Acc Noise (trust sensor less = higher number)
	kZ.Q[0] = 0.01f;
	kZ.Q[1] = 0.1f;


	while (1) {
		// 100Hz Loop (10ms)
		if (HAL_GetTick() - last_tick > 10) {
			HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13); // Heartbeat

			// 1. Process GPS
			if (gps_data_ready) {
				if (strstr(nmea_buffer, "GGA") != NULL) {
					Parse_GGA_Generic(nmea_buffer);
				}
				gps_data_ready = 0;
			}

			// 2. Read IMU
			MPU6050_Read_AccelGyro();

			// 3. Normalize Data
			f_ax = vehicleState.AccX / MPU_ACCEL_SENS;
			f_ay = vehicleState.AccY / MPU_ACCEL_SENS;
			f_az = vehicleState.AccZ / MPU_ACCEL_SENS;

			f_gx = (vehicleState.GyroX / MPU_GYRO_SENS) * DEG_TO_RAD;
			f_gy = (vehicleState.GyroY / MPU_GYRO_SENS) * DEG_TO_RAD;
			f_gz = (vehicleState.GyroZ / MPU_GYRO_SENS) * DEG_TO_RAD;

			// 4. Run MGDW Filter
			MadgwickUpdate(&rocketQ, f_ax, f_ay, f_az, f_gx, f_gy, f_gz);

			// 5. Calculate Linear Acceleration (Gravity Removed)
			GravityCorrection(&rocketQ, &lx, &ly, &lz, f_ax, f_ay, f_az);

			// 6. Run Kalman
			KPredict(&kZ, lz * 9.81f, dt);

			if (baro_update) {
				KUpdate(&kZ, vehicleState.BaroAlt, 1.0f);
				baro_update=0;
			}

			printf("%0.4f,%0.4f,%0.4f,%0.4f,%0.4f,%0.4f,%0.4f\n",rocketQ.q0,rocketQ.q1,rocketQ.q2,rocketQ.q3,vehicleState.Latitude,vehicleState.Longitude,kZ.pos);

			last_tick = HAL_GetTick();
		}
	}
}

/* --- Sensor Fusion Algorithms --- */

void KPredict(KState *k, float acc, float dt) {
	float dt2 = dt*dt;
	// 	state
	k->pos=k->pos+k->vel*dt+0.5*acc*dt2;
	k->vel=k->vel+acc*dt;
	// 	error
	float p00 = k->P[0][0];
	float p01 = k->P[0][1];
	float p10 = k->P[1][0];
	float p11 = k->P[1][1];

	k->P[0][0] = p00+(p10+p01*dt)+p11*dt2+k->Q[0];
	k->P[0][1] = p01+p11*dt;
	k->P[1][0] = p10+p11*dt;
	k->P[1][1] = p11+k->Q[1];

}

void KUpdate(KState *k, float m, float R){
	//calc innovation y
	float y = m-k->pos;
	//innovation cov S
	float S = k->P[0][0]+R;
	//Kalman gain - trust factor
	float K[2];
	K[0]= k->P[0][0]/S;
	K[1]= k->P[1][0]/S;
	//update the states
	k->pos = k->pos + K[0] * y;
	k->vel = k->vel + K[1] * y;
	//update cov mtx
	float p00 = k->P[0][0];
	float p01 = k->P[0][1];
	k->P[0][0]-=K[0]*p00;
	k->P[0][1]-=K[0]*p01;
	k->P[1][0]-=K[1]*p00;
	k->P[1][1]-=K[1]*p01;
}

void GravityCorrection(Quaternion_t *q, float *lx, float *ly, float *lz, float ax, float ay, float az) {
	float gx, gy, gz;
	float q0 = q->q0, q1 = q->q1, q2 = q->q2, q3 = q->q3;

	// Estimated gravity direction
	gx = 2.0f * (q1 * q3 - q0 * q2);
	gy = 2.0f * (q0 * q1 + q2 * q3);
	gz = q0 * q0 - q1 * q1 - q2 * q2 + q3 * q3;

	*lx = ax - gx;
	*ly = ay - gy;
	*lz = az - gz;
}

void MadgwickUpdate(Quaternion_t *q, float ax, float ay, float az, float gx, float gy, float gz) {
	float q0 = q->q0, q1 = q->q1, q2 = q->q2, q3 = q->q3;
	float norm, s0, s1, s2, s3, qDot1, qDot2, qDot3, qDot4;

	// Rate of change of quaternion from gyroscope
	qDot1 = 0.5f * (-q1 * gx - q2 * gy - q3 * gz);
	qDot2 = 0.5f * ( q0 * gx + q2 * gz - q3 * gy);
	qDot3 = 0.5f * ( q0 * gy - q1 * gz + q3 * gx);
	qDot4 = 0.5f * ( q0 * gz + q1 * gy - q2 * gx);

	// Compute feedback only if accelerometer measurement valid
	if (!((ax == 0.0f) && (ay == 0.0f) && (az == 0.0f))) {
		// Normalise accelerometer measurement
		norm = sqrtf(ax * ax + ay * ay + az * az);
		if (norm == 0.0f) return;
		ax /= norm; ay /= norm; az /= norm;

		// Gradient decent algorithm corrective step
		float _2q0 = 2.0f * q0, _2q1 = 2.0f * q1, _2q2 = 2.0f * q2, _2q3 = 2.0f * q3;
		float _4q0 = 4.0f * q0, _4q1 = 4.0f * q1, _4q2 = 4.0f * q2;
		float _8q1 = 8.0f * q1, _8q2 = 8.0f * q2;
		float q0q0 = q0 * q0, q1q1 = q1 * q1, q2q2 = q2 * q2, q3q3 = q3 * q3;

		s0 = _4q0 * q2q2 + _2q2 * ax + _4q0 * q1q1 - _2q1 * ay;
		s1 = _4q1 * q3q3 - _2q3 * ax + 4.0f * q0q0 * q1 - _2q0 * ay - _4q1 + _8q1 * q1q1 + _8q1 * q2q2 + _4q1 * az;
		s2 = 4.0f * q0q0 * q2 + _2q0 * ax + _4q2 * q3q3 - _2q3 * ay - _4q2 + _8q2 * q1q1 + _8q2 * q2q2 + _4q2 * az;
		s3 = 4.0f * q1q1 * q3 - _2q1 * ax + 4.0f * q2q2 * q3 - _2q2 * ay;

		norm = sqrtf(s0 * s0 + s1 * s1 + s2 * s2 + s3 * s3);
		if (norm > 0.0f) {
			s0 /= norm; s1 /= norm; s2 /= norm; s3 /= norm;
			qDot1 -= q->beta * s0;
			qDot2 -= q->beta * s1;
			qDot3 -= q->beta * s2;
			qDot4 -= q->beta * s3;
		}
	}

	// Integrate to yield quaternion
	float dt = 1.0f / q->sampleFreq;
	q0 += qDot1 * dt;
	q1 += qDot2 * dt;
	q2 += qDot3 * dt;
	q3 += qDot4 * dt;

	// Normalise quaternion
	norm = sqrtf(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
	if (norm > 0.0f) {
		q->q0 = q0 / norm;
		q->q1 = q1 / norm;
		q->q2 = q2 / norm;
		q->q3 = q3 / norm;
	}
}

/* --- Interrupt Handlers --- */

void USART2_IRQHandler(void) {
	HAL_UART_IRQHandler(&huart2);
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
	// GPS Handling
	if (huart->Instance == USART1) {
		if (gps_rx_char == '\n' || nmea_idx >= NMEA_BUFFER_SIZE - 1) {
			nmea_buffer[nmea_idx] = '\0';
			gps_data_ready = 1;
			nmea_idx = 0;
		} else if (gps_rx_char != '\r') {
			nmea_buffer[nmea_idx++] = gps_rx_char;
		}
		HAL_UART_Receive_IT(&huart1, &gps_rx_char, 1);
	}
	// Barometer Handling
	else if (huart->Instance == USART2) {
		switch (baro_state) {
		case 0: // Header
			if (baro_rx_byte == BARO_HEADER) {
				baro_idx = 0;
				baro_state = 1;
			}
			break;
		case 1: // Data
			baro_buffer[baro_idx++] = baro_rx_byte;
			if (baro_idx >= 4) baro_state = 2;
			break;
		case 2: // Footer
			if (baro_rx_byte == BARO_FOOTER) {
				memcpy(&vehicleState.BaroAlt, baro_buffer, 4);
			}
			baro_state = 0;
			break;
		}
		baro_update=1;
		HAL_UART_Receive_IT(&huart2, &baro_rx_byte, 1);
	}
}

void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart) {
	volatile uint32_t er = HAL_UART_GetError(huart); // Clear Flags
	(void)er;
	if (huart->Instance == USART2) HAL_UART_Receive_IT(&huart2, &baro_rx_byte, 1);
	if (huart->Instance == USART1) HAL_UART_Receive_IT(&huart1, &gps_rx_char, 1);
}

/* --- Hardware Drivers & Helpers --- */

// Redirect printf to UART2
int _write(int file, char *ptr, int len) {
	HAL_UART_Transmit(&huart2, (uint8_t*) ptr, len, HAL_MAX_DELAY);
	return len;
}

uint8_t MPU6050_Init(void) {
	uint8_t check, data;
	HAL_I2C_Mem_Read(&hi2c1, MPU6050_ADDR, MPU_REG_WHO_AM_I, 1, &check, 1, 1000);

	if (check == 0x68) {
		data = 0x00; HAL_I2C_Mem_Write(&hi2c1, MPU6050_ADDR, MPU_REG_PWR_MGMT_1, 1, &data, 1, 1000);
		data = 0x18; HAL_I2C_Mem_Write(&hi2c1, MPU6050_ADDR, MPU_REG_GYRO_CONFIG, 1, &data, 1, 1000);
		data = 0x18; HAL_I2C_Mem_Write(&hi2c1, MPU6050_ADDR, MPU_REG_ACCEL_CONFIG, 1, &data, 1, 1000);
		return 0; // OK
	}
	return 1; // Error
}

void MPU6050_Calibrate(void) {
	int32_t Aa[3] = {0}, Ag[3] = {0};
	uint8_t Rec[14];

	// Accumulate samples
	for (int i = 0; i < 1000; i++) {
		HAL_I2C_Mem_Read(&hi2c1, MPU6050_ADDR, MPU_REG_ACCEL_XOUT_H, 1, Rec, 14, 100);
		Aa[0] += (int16_t)(Rec[0] << 8 | Rec[1]);
		Aa[1] += (int16_t)(Rec[2] << 8 | Rec[3]);
		Aa[2] += (int16_t)(Rec[4] << 8 | Rec[5]);
		Ag[0] += (int16_t)(Rec[8] << 8 | Rec[9]);
		Ag[1] += (int16_t)(Rec[10] << 8 | Rec[11]);
		Ag[2] += (int16_t)(Rec[12] << 8 | Rec[13]);
		HAL_Delay(1);
	}

	// Averages
	int16_t AvgX = Aa[0]/1000, AvgY = Aa[1]/1000, AvgZ = Aa[2]/1000;

	// Detect Vertical Axis
	if      (abs(AvgX) > abs(AvgY) && abs(AvgX) > abs(AvgZ)) { Vertical_Axis = 0; Vertical_Sign = (AvgX > 0) ? 1 : -1; }
	else if (abs(AvgY) > abs(AvgX) && abs(AvgY) > abs(AvgZ)) { Vertical_Axis = 1; Vertical_Sign = (AvgY > 0) ? 1 : -1; }
	else                                                     { Vertical_Axis = 2; Vertical_Sign = (AvgZ > 0) ? 1 : -1; }

	Gyro_Offset[0] = Ag[0] / 1000;
	Gyro_Offset[1] = Ag[1] / 1000;
	Gyro_Offset[2] = Ag[2] / 1000;

	int16_t gRaw = (int16_t)MPU_ACCEL_SENS * Vertical_Sign;
	Acc_Offset[0] = AvgX - (Vertical_Axis == 0 ? gRaw : 0);
	Acc_Offset[1] = AvgY - (Vertical_Axis == 1 ? gRaw : 0);
	Acc_Offset[2] = AvgZ - (Vertical_Axis == 2 ? gRaw : 0);
}

void MPU6050_Read_AccelGyro(void) {
	uint8_t Rec[14];
	HAL_I2C_Mem_Read(&hi2c1, MPU6050_ADDR, MPU_REG_ACCEL_XOUT_H, 1, Rec, 14, 100);

	int16_t rawA[3], rawG[3];
	rawA[0] = (int16_t)(Rec[0] << 8 | Rec[1]) - Acc_Offset[0];
	rawA[1] = (int16_t)(Rec[2] << 8 | Rec[3]) - Acc_Offset[1];
	rawA[2] = (int16_t)(Rec[4] << 8 | Rec[5]) - Acc_Offset[2];

	rawG[0] = (int16_t)(Rec[8] << 8 | Rec[9]) - Gyro_Offset[0];
	rawG[1] = (int16_t)(Rec[10] << 8 | Rec[11]) - Gyro_Offset[1];
	rawG[2] = (int16_t)(Rec[12] << 8 | Rec[13]) - Gyro_Offset[2];

	// Remap Axis based on Calibration
	if (Vertical_Axis == 0) { // X-Up
		vehicleState.AccX = rawA[2]; vehicleState.AccY = rawA[1]; vehicleState.AccZ = rawA[0] * Vertical_Sign;
		vehicleState.GyroX = rawG[2]; vehicleState.GyroY = rawG[1]; vehicleState.GyroZ = rawG[0] * Vertical_Sign;
	} else if (Vertical_Axis == 1) { // Y-Up
		vehicleState.AccX = rawA[0]; vehicleState.AccY = rawA[2]; vehicleState.AccZ = rawA[1] * Vertical_Sign;
		vehicleState.GyroX = rawG[0]; vehicleState.GyroY = rawG[2]; vehicleState.GyroZ = rawG[1] * Vertical_Sign;
	} else { // Z-Up (Default)
		vehicleState.AccX = rawA[0]; vehicleState.AccY = rawA[1]; vehicleState.AccZ = rawA[2] * Vertical_Sign;
		vehicleState.GyroX = rawG[0]; vehicleState.GyroY = rawG[1]; vehicleState.GyroZ = rawG[2] * Vertical_Sign;
	}
}

void Parse_GGA_Generic(char *nmea) {
	char *p = nmea;
	int field = 0;
	while (*p) {
		char *end = strchr(p, ',');
		if (end) *end = '\0';

		if (*p) {
			switch (field) {
			case 2: vehicleState.Latitude = atof(p); break;
			case 4: vehicleState.Longitude = atof(p); break;
			case 6: vehicleState.FixStatus = atoi(p); break;
			case 7: vehicleState.Satellites = atoi(p); break;
			}
		}
		if (!end) break;
		p = end + 1;
		field++;
	}
}

/* --- Initialization Boilerplate --- */
void SystemClock_Config(void) {
	RCC_OscInitTypeDef RCC_OscInitStruct = {0};
	RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
	__HAL_RCC_PWR_CLK_ENABLE();
	__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
	RCC_OscInitStruct.HSIState = RCC_HSI_ON;
	RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
	RCC_OscInitStruct.PLL.PLLM = 8;
	RCC_OscInitStruct.PLL.PLLN = 84;
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
	RCC_OscInitStruct.PLL.PLLQ = 4;
	HAL_RCC_OscConfig(&RCC_OscInitStruct);
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
	HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
}

static void MX_I2C1_Init(void) {
	hi2c1.Instance = I2C1;
	hi2c1.Init.ClockSpeed = 100000;
	hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
	hi2c1.Init.OwnAddress1 = 0;
	hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
	hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
	hi2c1.Init.OwnAddress2 = 0;
	hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
	hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
	HAL_I2C_Init(&hi2c1);
}

static void MX_USART1_UART_Init(void) {
	huart1.Instance = USART1;
	huart1.Init.BaudRate = 9600;
	huart1.Init.WordLength = UART_WORDLENGTH_8B;
	huart1.Init.StopBits = UART_STOPBITS_1;
	huart1.Init.Parity = UART_PARITY_NONE;
	huart1.Init.Mode = UART_MODE_TX_RX;
	huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
	huart1.Init.OverSampling = UART_OVERSAMPLING_16;
	HAL_UART_Init(&huart1);
}

static void MX_USART2_UART_Init(void) {
	huart2.Instance = USART2;
	huart2.Init.BaudRate = 115200;
	huart2.Init.WordLength = UART_WORDLENGTH_8B;
	huart2.Init.StopBits = UART_STOPBITS_1;
	huart2.Init.Parity = UART_PARITY_NONE;
	huart2.Init.Mode = UART_MODE_TX_RX;
	huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
	huart2.Init.OverSampling = UART_OVERSAMPLING_16;
	if (HAL_UART_Init(&huart2) != HAL_OK) Error_Handler();

	// Explicit Interrupt Enable
	HAL_NVIC_SetPriority(USART2_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(USART2_IRQn);
}

static void MX_GPIO_Init(void) {
	GPIO_InitTypeDef GPIO_InitStruct = {0};
	__HAL_RCC_GPIOC_CLK_ENABLE();
	__HAL_RCC_GPIOA_CLK_ENABLE();
	__HAL_RCC_GPIOB_CLK_ENABLE();
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);
	GPIO_InitStruct.Pin = GPIO_PIN_13;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
}

void Error_Handler(void) {
	__disable_irq();
	while (1) {}
}
